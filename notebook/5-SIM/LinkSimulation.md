```python
from pylayers.simul.link import *
%matplotlib inline
import seaborn as sns
sns.set_style("dark")
```

# How to do Ray Tracing simulation using DLink

This section illustrates the [`link`](http://pylayers.github.io/pylayers/modules/pylayers.simul.link.html) module.
A `Dlink` object is a deterministic link.


The anchor nodes in the Layout are defined as

```python
AnchorNodes = {390:{'name':'MT_ACO_05','coord':[6,0.81,1.64]},
               386:{'name':'MT_ACO_08','coord':[30.574,2.8,1.291]},
                391:{'name':'MT_ACO_07','coord':[11.78,-5.553,1.5]},
                385:{'name': 'MT_ACO_01','coord':[19.52,-0.69,1.446]},
                387:{'name':'MT_ACO_03','coord':[28.606,-0.74,1.467]},
                400:{'name':'MT_ACO_02','coord':[30.574,2.8,1.291]},
                1:{'name':'MT_DLR_RTDSlave','coord':[0.85,0,1.18]}
               }
```

```python
L = Layout('DLR2.lay')
DL=DLink(L=L)
DL.a = np.array(AnchorNodes[390]['coord'])
DL.b = np.array(AnchorNodes[385]['coord'])
```

```python
DL.help()
```

```python
DL
```


To evaluate a link there is the `eval` method.

This method takes as argument 
+ a list of the desired outputs,
+ the type of algorithm being used, 
+ the ceil height
+ the number of multi reflection between ceil and floor.

```python
DL.eval()
```

```python
DL.R.show(L=DL.L,figsize=(10,10))
```

```python
DL.H.taud
```

```python
DL.eval(force=[], output=['sig','ray','Ct','H'],
         si_algo='old',ra_ceil_height_meter=3,ra_number_mirror_cf=1)
```


The propagation channel (without antenna) can be vizualized on a ray by ray mode.

```python
type(DL.C)
```

```python
DL._show3()
sns.set_style("dark")
```

```python
fig = plt.figure(figsize=(8,8))
C = DL.C
f,a = C.show(cmap='jet',fig=fig,typ='l10',vmin=-100,vmax=-10)
```

It is possible to look at individual ray transfer function, as illustrated below.

```python
C.Ctt.y.shape
```

```python
ir = 80
plt.plot(C.Ctt.x,abs(C.Ctt.y[ir,:]))
plt.xlabel('Frequency (GHz)')
plt.ylabel('Level (linear)')
plt.title('Modulus of the ray '+str(ir)+' transfer function')
```

```python
ir = 30
plt.plot(C.Ctt.x,abs(C.Ctt.y[ir,:]))
plt.xlabel('Frequency (GHz)')
plt.ylabel('Level (linear)')
plt.title('Modulus of the ray '+str(ir)+' transfer function')
```

In the link we also have the transmission channel accounting for the effect of
antennas and Friis factor. If the ray transfer function is scaled with
$\frac{4\pi f}{c}$

```python
plt.plot(L.H.x,L.H.y[0,:]*4*np.pi*L.H.x/0.3)
```

The infinite bandwidth channel impulse response is plotted below from the extrated set $\{\alpha_k,\tau_k\}$.

```python
#plt.stem(aktk[1],aktk[0])
#plt.title('Infinite bandwith Channel Impulse response')
#plt.xlabel('delay (ns)')
#plt.ylabel('amplitude (linear scale')
```

```python
import pylayers.simul.simulnet as sn
import pylayers.simul.simultraj as st
```

```python
S=sn.Simul()
Layout graphs are loaded from /home/uguen/Bureau/P1/struc/ini
```

```python
S.L
```

```python
S.runsimul()
```

```python
dB=True
from pylayers.mobility.trajectory import *
```

A trajectories object is a list of trajectory. The loadh5 methods by default loads the file '.h5'
generated by [`Simulnet`](http://pylayers.github.io/pylayers/modules/pylayers.simul.simulnet.html).

```python
T=Trajectories()
T.loadh5()
```

```python
T
```

A SimulTraj object is derived from a trajectory calculated previously in simulnet and a body agent description.
The Simultraj object get the trajectories from the `simultaj.ini` file.

```python
St = st.Simul(verbose=False)
```

```python
St.run(t=list(np.arange(0,1,0.1)),OB=True,B2B=True,B2I=True)
```

```python
St.data
```

Information about the simulated network is obtained

```python
St.N
```

```python
St._show3()
```

```python
St.data.head()
```

```python
#ak,tk,ek=St._loadh5(2,'0_Alex','1_Alex','bluetooth-class2')
```
